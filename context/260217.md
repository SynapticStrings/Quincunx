# 基于 Orchid 构建虚拟歌姬编辑器的增量计算引擎

Model: GLM 5 + Claude Opus 4

---

## 1. 问题域建模

首先明确你的核心需求：

```
Song
 └── Track
      └── [Segment₁, Segment₂, ..., Segmentₙ]  (乐句)
           │
           ├── 有的修改了音符/发音 → 需要从头生成（完整 pipeline）
           ├── 有的只改了后续参数   → 只需重新渲染末段（部分 pipeline）
           └── 有的完全没改        → 跳过（直接复用 snapshot）
```

这里面有三层核心问题：

1. **每个 Segment 内部**：一个多阶段的 DAG pipeline（音素提取 → 声学模型 → 参数生成 → 渲染）
2. **Segment 之间**：批量调度，异质依赖图（不同 segment 的 pipeline 深度不同）
3. **时间维度**：基于 Snapshot/Checkpoint 的 diff，决定每个 segment 从哪个阶段开始重算

---

## 2. 架构设计

### 2.1 分层架构总览

```
┌─────────────────────────────────────────────────────┐
│                   Editor UI (LiveView)              │
├─────────────────────────────────────────────────────┤
│              Incremental Engine (调度层)              │
│  ┌───────────┐  ┌────────────┐  ┌────────────────┐ │
│  │ DiffEngine│  │SegmentPool │  │ SnapshotStore  │ │
│  │ (变更检测) │  │ (批量调度)  │  │ (检查点管理)   │ │
│  └───────────┘  └────────────┘  └────────────────┘ │
├─────────────────────────────────────────────────────┤
│              Orchid Layer (计算层)                    │
│  ┌──────────────────────────────────────────────┐   │
│  │  Per-Segment Recipes (动态生成的异质 DAG)      │   │
│  │  Recipe_full / Recipe_partial / Recipe_render  │   │
│  └──────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────┤
│              Synthesis Backend (合成后端)             │
│  Phoneme extraction, Acoustic model, Vocoder, etc. │
└─────────────────────────────────────────────────────┘
```

### 2.2 核心数据模型

```elixir
defmodule Cantor.Segment do
  @moduledoc """
  一个乐句的完整状态描述。
  """
  defstruct [
    :id,
    :track_id,
    :notes,           # 音符列表 [{pitch, duration, lyric}, ...]
    :phoneme_hints,   # 用户手动调整的音素
    :parameters,      # 后续参数（如力度曲线、气息、张力等）
    :render_config,   # 渲染配置（模型选择、引擎参数等）
    :version          # 单调递增版本号
  ]
end

defmodule Cantor.Snapshot do
  @moduledoc """
  某个 Segment 在某个 pipeline 阶段的计算快照。
  """
  defstruct [
    :segment_id,
    :segment_version,
    :stage,            # :phonemes | :acoustics | :parameters | :rendered
    :data,             # 该阶段的计算结果
    :timestamp,
    :input_hash        # 用于快速比对该阶段输入是否变化
  ]
end
```

---

## 3. 增量计算的核心：Diff 引擎

这是整个系统最关键的部分——决定每个 segment 需要从哪里开始重算。

### 3.1 变更分类

```elixir
defmodule Cantor.DiffEngine do
  @moduledoc """
  比较 Segment 的新旧状态，确定需要重算的最小阶段。
  """

  @type change_level :: :none | :render_only | :parameters | :acoustics | :full

  @doc """
  Pipeline 阶段的依赖关系（越靠后依赖越少的前置阶段）：
  
    notes/lyrics ──→ phonemes ──→ acoustics ──→ parameters ──→ render
        ↑               ↑            ↑              ↑            ↑
      :full          :full       :acoustics    :parameters  :render_only
  """
  @spec classify(old :: Segment.t(), new :: Segment.t()) :: change_level()
  def classify(old, new) do
    cond do
      old == new ->
        :none

      notes_or_lyrics_changed?(old, new) ->
        :full

      phoneme_hints_changed?(old, new) ->
        :full

      # 声学相关参数变了（如音高曲线的大幅调整）
      acoustic_params_changed?(old, new) ->
        :acoustics

      # 只有后处理参数变了（力度、气息等曲线微调）
      post_params_changed?(old, new) ->
        :parameters

      # 只有渲染配置变了（输出格式、采样率等）
      render_config_changed?(old, new) ->
        :render_only

      true ->
        :none
    end
  end

  @doc """
  批量 diff：对一组 segments 统一分类。
  返回按 change_level 分组的结果。
  """
  @spec batch_classify(
    old_segments :: %{segment_id => Segment.t()},
    new_segments :: %{segment_id => Segment.t()}
  ) :: %{change_level() => [segment_id]}
  def batch_classify(old_map, new_map) do
    new_map
    |> Enum.map(fn {id, new_seg} ->
      old_seg = Map.get(old_map, id)
      level = if old_seg, do: classify(old_seg, new_seg), else: :full
      {level, id}
    end)
    |> Enum.group_by(&elem(&1, 0), &elem(&1, 1))
  end
end
```

### 3.2 Input Hash 实现快速比对

对于更精细的缓存命中判断，可以对每个阶段的输入做 hash：

```elixir
defmodule Cantor.InputHash do
  @doc """
  计算某个阶段输入的 hash，用于判断 snapshot 是否仍然有效。
  """
  def hash_for_stage(segment, :phonemes) do
    :erlang.phash2({segment.notes, segment.phoneme_hints})
  end

  def hash_for_stage(segment, :acoustics) do
    :erlang.phash2({segment.notes, segment.phoneme_hints, acoustic_fields(segment)})
  end

  def hash_for_stage(segment, :parameters) do
    :erlang.phash2({segment.notes, segment.parameters})
  end

  def hash_for_stage(segment, :render) do
    :erlang.phash2({segment.parameters, segment.render_config})
  end
end
```

---

## 4. 用 Orchid 构建异质 Pipeline

这是将 Orchid 的 DAG 引擎与增量计算结合的核心。

### 4.1 定义 Steps

```elixir
defmodule Cantor.Steps.ExtractPhonemes do
  use Orchid.Step

  @impl true
  def run(notes_param, opts) do
    notes = notes_param.payload
    language = Keyword.get(opts, :language, :japanese)
    
    phonemes = PhonemeEngine.extract(notes, language)
    
    {:ok, Orchid.Param.new(:phonemes, :list, phonemes, %{
      count: length(phonemes)
    })}
  end
end

defmodule Cantor.Steps.AcousticModel do
  use Orchid.Step

  @impl true
  def run({phonemes_param, params_param}, opts) do
    model = Keyword.fetch!(opts, :model)
    phonemes = phonemes_param.payload
    params = params_param.payload
    
    acoustics = AcousticEngine.infer(model, phonemes, params)
    
    {:ok, Orchid.Param.new(:acoustics, :tensor, acoustics)}
  end
end

defmodule Cantor.Steps.GenerateParameters do
  use Orchid.Step

  @impl true
  def run({acoustics_param, user_params_param}, _opts) do
    acoustics = acoustics_param.payload
    user_params = user_params_param.payload
    
    # 合并模型输出的参数与用户手动调整的参数
    final_params = ParameterEngine.merge(acoustics, user_params)
    
    {:ok, Orchid.Param.new(:final_parameters, :map, final_params)}
  end
end

defmodule Cantor.Steps.Render do
  use Orchid.Step

  @impl true
  def run(final_params_param, opts) do
    vocoder = Keyword.get(opts, :vocoder, :world)
    params = final_params_param.payload
    
    audio = Vocoder.synthesize(vocoder, params)
    
    {:ok, Orchid.Param.new(:audio, :binary, audio, %{
      sample_rate: 44100,
      duration_ms: byte_size(audio) / 44100 * 1000
    })}
  end
end
```

### 4.2 动态生成异质 Recipe

**这是关键创新点**——根据 diff 结果，为每个 segment 动态生成不同深度的 recipe：

```elixir
defmodule Cantor.RecipeFactory do
  alias Orchid.{Recipe, Param}

  @doc """
  根据变更级别和已有 snapshot，动态生成该 segment 需要执行的 recipe。
  
  :full        → [ExtractPhonemes → AcousticModel → GenerateParameters → Render]
  :acoustics   → [AcousticModel → GenerateParameters → Render]  (复用 phonemes snapshot)
  :parameters  → [GenerateParameters → Render]                   (复用 acoustics snapshot)
  :render_only → [Render]                                        (复用 parameters snapshot)
  :none        → nil                                             (完全跳过)
  """
  @spec build(Segment.t(), change_level(), [Snapshot.t()]) ::
    {Recipe.t() | nil, [Param.t()]}
  def build(_segment, :none, _snapshots), do: {nil, []}

  def build(segment, change_level, snapshots) do
    {steps, initial_params} = 
      case change_level do
        :full ->
          {
            full_steps(segment),
            [
              Param.new(:notes, :list, segment.notes),
              Param.new(:user_parameters, :map, segment.parameters),
              Param.new(:render_config, :map, segment.render_config)
            ]
          }

        :acoustics ->
          phonemes_snapshot = find_snapshot(snapshots, segment.id, :phonemes)
          {
            steps_from(:acoustics, segment),
            [
              Param.new(:phonemes, :list, phonemes_snapshot.data),
              Param.new(:user_parameters, :map, segment.parameters),
              Param.new(:render_config, :map, segment.render_config)
            ]
          }

        :parameters ->
          acoustics_snapshot = find_snapshot(snapshots, segment.id, :acoustics)
          {
            steps_from(:parameters, segment),
            [
              Param.new(:acoustics, :tensor, acoustics_snapshot.data),
              Param.new(:user_parameters, :map, segment.parameters),
              Param.new(:render_config, :map, segment.render_config)
            ]
          }

        :render_only ->
          params_snapshot = find_snapshot(snapshots, segment.id, :parameters)
          {
            [render_step(segment)],
            [
              Param.new(:final_parameters, :map, params_snapshot.data)
            ]
          }
      end

    recipe = Recipe.new(steps, name: :"segment_#{segment.id}_#{change_level}")
    {recipe, initial_params}
  end

  defp full_steps(segment) do
    [
      {Cantor.Steps.ExtractPhonemes, :notes, :phonemes, 
        [language: detect_language(segment)]},
      {Cantor.Steps.AcousticModel, {:phonemes, :user_parameters}, :acoustics,
        [model: segment.render_config.model]},
      {Cantor.Steps.GenerateParameters, {:acoustics, :user_parameters}, :final_parameters, []},
      {Cantor.Steps.Render, :final_parameters, :audio,
        [vocoder: segment.render_config.vocoder]}
    ]
  end

  defp steps_from(:acoustics, segment) do
    full_steps(segment) |> Enum.drop(1)  # skip phoneme extraction
  end

  defp steps_from(:parameters, segment) do
    full_steps(segment) |> Enum.drop(2)  # skip phoneme + acoustic
  end

  defp render_step(segment) do
    {Cantor.Steps.Render, :final_parameters, :audio,
      [vocoder: segment.render_config.vocoder]}
  end
end
```

---

## 5. 批量调度器

处理你提到的 `[A, AB, AB, C, C, ...]` 异质批量场景：

### 5.1 批量编排器

```elixir
defmodule Cantor.BatchOrchestrator do
  require Logger

  @doc """
  接受一批 segment 的变更，执行增量计算。
  
  核心流程：
  1. Diff → 分类
  2. 按 change_level 分组
  3. 为每个 segment 动态生成 recipe
  4. 并发执行所有 recipe
  5. 收集结果，更新 snapshots
  """
  def execute_batch(old_segments, new_segments, snapshot_store) do
    # Phase 1: Diff
    changes = Cantor.DiffEngine.batch_classify(old_segments, new_segments)
    
    Logger.info("Batch diff: #{inspect(Map.new(changes, fn {k, v} -> {k, length(v)} end))}")
    # e.g., %{full: 1, parameters: 2, render_only: 3, none: 10}

    # Phase 2: Build recipes (skip :none)
    tasks =
      changes
      |> Enum.reject(fn {level, _} -> level == :none end)
      |> Enum.flat_map(fn {level, segment_ids} ->
        Enum.map(segment_ids, fn seg_id ->
          segment = Map.fetch!(new_segments, seg_id)
          snapshots = Cantor.SnapshotStore.get_all(snapshot_store, seg_id)
          {segment, level, Cantor.RecipeFactory.build(segment, level, snapshots)}
        end)
      end)

    # Phase 3: Concurrent execution with controlled parallelism
    max_concurrency = System.schedulers_online()
    
    results =
      Task.async_stream(
        tasks,
        fn {segment, level, {recipe, initial_params}} ->
          execute_single(segment, level, recipe, initial_params)
        end,
        max_concurrency: max_concurrency,
        timeout: 30_000,
        on_timeout: :kill_task
      )
      |> Enum.map(fn
        {:ok, result} -> result
        {:exit, reason} -> {:error, reason}
      end)

    # Phase 4: Update snapshots
    Enum.each(results, fn
      {:ok, segment_id, stage_results} ->
        Cantor.SnapshotStore.save_batch(snapshot_store, segment_id, stage_results)
      {:error, _reason} ->
        :skip  # 或者记录到失败队列
    end)

    results
  end

  defp execute_single(segment, level, recipe, initial_params) do
    # 使用 Snapshot Hook 在每个阶段完成后自动保存中间结果
    hooks = [Cantor.Hooks.SnapshotCapture]
    
    case Orchid.run(recipe, initial_params,
      executor_and_opts: {Orchid.Executor.Serial, []},  # 单 segment 内串行
      global_hooks_stack: hooks,
      baggage: %{
        segment_id: segment.id,
        segment_version: segment.version,
        change_level: level
      }
    ) do
      {:ok, results} ->
        {:ok, segment.id, results}
      {:error, error} ->
        Logger.error("Segment #{segment.id} failed: #{inspect(error)}")
        {:error, {segment.id, error}}
    end
  end
end
```

### 5.2 Snapshot Capture Hook

利用 Orchid 的 Hook 机制，在每个 step 完成后自动捕获 snapshot：

```elixir
defmodule Cantor.Hooks.SnapshotCapture do
  @behaviour Orchid.Runner.Hook

  @impl true
  def call(ctx, next) do
    case next.(ctx) do
      {:ok, result} = success ->
        # 每个 step 成功后，异步保存 snapshot
        workflow_ctx = ctx.workflow_ctx
        segment_id = Orchid.WorkflowCtx.get_baggage(workflow_ctx, :segment_id)
        version = Orchid.WorkflowCtx.get_baggage(workflow_ctx, :segment_version)
        
        stage = step_to_stage(ctx.step_implementation)
        
        if stage do
          Task.start(fn ->
            Cantor.SnapshotStore.save(segment_id, %Cantor.Snapshot{
              segment_id: segment_id,
              segment_version: version,
              stage: stage,
              data: result.payload,
              timestamp: System.monotonic_time(),
              input_hash: compute_input_hash(ctx)
            })
          end)
        end
        
        success

      error ->
        error
    end
  end

  defp step_to_stage(Cantor.Steps.ExtractPhonemes), do: :phonemes
  defp step_to_stage(Cantor.Steps.AcousticModel), do: :acoustics
  defp step_to_stage(Cantor.Steps.GenerateParameters), do: :parameters
  defp step_to_stage(Cantor.Steps.Render), do: :render
  defp step_to_stage(_), do: nil
end
```

---

## 6. Snapshot Store

管理检查点的存储，支持快速查询和清理：

```elixir
defmodule Cantor.SnapshotStore do
  use GenServer

  @moduledoc """
  管理所有 segment 的 pipeline 中间结果快照。
  使用 ETS 实现高性能并发读取。
  """

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    table = :ets.new(:snapshots, [
      :set, :public, :named_table,
      read_concurrency: true,
      write_concurrency: true
    ])
    {:ok, %{table: table}}
  end

  @doc "获取某个 segment 某阶段的最新 snapshot"
  def get(segment_id, stage) do
    case :ets.lookup(:snapshots, {segment_id, stage}) do
      [{_key, snapshot}] -> snapshot
      [] -> nil
    end
  end

  @doc "获取某个 segment 的所有阶段 snapshots"
  def get_all(_store \\ __MODULE__, segment_id) do
    [:phonemes, :acoustics, :parameters, :render]
    |> Enum.map(fn stage -> get(segment_id, stage) end)
    |> Enum.reject(&is_nil/1)
  end

  @doc "保存一个 snapshot"
  def save(segment_id, %Cantor.Snapshot{} = snapshot) do
    :ets.insert(:snapshots, {{segment_id, snapshot.stage}, snapshot})
    :ok
  end

  @doc "批量保存某个 segment 的阶段结果"
  def save_batch(_store \\ __MODULE__, segment_id, results) when is_map(results) do
    Enum.each(results, fn {key, param} ->
      stage = param_key_to_stage(key)
      if stage do
        save(segment_id, %Cantor.Snapshot{
          segment_id: segment_id,
          stage: stage,
          data: param.payload,
          timestamp: System.monotonic_time()
        })
      end
    end)
  end

  @doc "当 segment 被删除时，清理其所有 snapshots"
  def invalidate(segment_id) do
    [:phonemes, :acoustics, :parameters, :render]
    |> Enum.each(fn stage ->
      :ets.delete(:snapshots, {segment_id, stage})
    end)
  end

  defp param_key_to_stage(:phonemes), do: :phonemes
  defp param_key_to_stage(:acoustics), do: :acoustics
  defp param_key_to_stage(:final_parameters), do: :parameters
  defp param_key_to_stage(:audio), do: :render
  defp param_key_to_stage(_), do: nil
end
```

---

## 7. 实时编辑体验：Debounce + Priority

编辑器场景下用户会频繁修改，需要防抖和优先级调度：

```elixir
defmodule Cantor.EditSession do
  use GenServer

  @moduledoc """
  管理单个编辑会话。
  - 收集用户变更，debounce 后批量提交
  - 如果新的变更到来且旧计算还在进行中，取消旧计算
  """

  defstruct [
    :track_id,
    :current_segments,     # 当前已确认的 segment 状态
    :pending_changes,      # 待处理的变更缓冲区
    :debounce_timer,       # 防抖定时器
    :running_task,         # 当前正在执行的批量计算
    debounce_ms: 300       # 默认 300ms 防抖
  ]

  def start_link(track_id, initial_segments) do
    GenServer.start_link(__MODULE__, {track_id, initial_segments},
      name: via_tuple(track_id))
  end

  @doc "用户修改了一个 segment"
  def update_segment(track_id, segment_id, changes) do
    GenServer.cast(via_tuple(track_id), {:update, segment_id, changes})
  end

  @impl true
  def handle_cast({:update, segment_id, changes}, state) do
    # 累积变更
    pending = Map.update(state.pending_changes, segment_id, changes,
      &Map.merge(&1, changes))
    
    # 重置 debounce 定时器
    if state.debounce_timer, do: Process.cancel_timer(state.debounce_timer)
    timer = Process.send_after(self(), :flush, state.debounce_ms)
    
    {:noreply, %{state | pending_changes: pending, debounce_timer: timer}}
  end

  @impl true
  def handle_info(:flush, state) do
    # 如果有正在运行的计算，先取消
    if state.running_task do
      Task.shutdown(state.running_task, :brutal_kill)
    end

    # 应用 pending changes，生成新的 segments
    new_segments = apply_changes(state.current_segments, state.pending_changes)
    
    # 启动批量增量计算
    task = Task.async(fn ->
      Cantor.BatchOrchestrator.execute_batch(
        state.current_segments,
        new_segments,
        Cantor.SnapshotStore
      )
    end)

    {:noreply, %{state |
      pending_changes: %{},
      debounce_timer: nil,
      running_task: task,
      current_segments: new_segments  # optimistic update
    }}
  end

  @impl true
  def handle_info({ref, results}, state) when is_reference(ref) do
    # Task 完成
    Process.demonitor(ref, [:flush])
    
    # 通知 UI 更新
    broadcast_results(state.track_id, results)
    
    {:noreply, %{state | running_task: nil}}
  end

  @impl true
  def handle_info({:DOWN, _ref, :process, _pid, _reason}, state) do
    {:noreply, %{state | running_task: nil}}
  end

  defp via_tuple(track_id), do: {:via, Registry, {Cantor.Registry, {:session, track_id}}}
end
```

---

## 8. 完整执行流程图

```
用户编辑 Segment₃ 的音高曲线
        │
        ▼
  EditSession (debounce 300ms)
        │
        ▼ (flush)
  DiffEngine.batch_classify
  ┌──────────────────────────────────────────────────┐
  │ Seg₁: :none       → skip                         │
  │ Seg₂: :none       → skip                         │
  │ Seg₃: :parameters → rebuild from acoustics stage  │
  │ Seg₄: :none       → skip                         │
  └──────────────────────────────────────────────────┘
        │
        ▼
  RecipeFactory.build(seg₃, :parameters, snapshots)
  ┌──────────────────────────────────────────────────┐
  │ Initial params:                                   │
  │   :acoustics ← from snapshot (cached!)            │
  │   :user_parameters ← new values from user         │
  │   :render_config ← unchanged                      │
  │                                                   │
  │ Recipe (2 steps only!):                           │
  │   GenerateParameters → Render                     │
  └──────────────────────────────────────────────────┘
        │
        ▼
  Orchid.run(recipe, params)
  ┌──────────────────────────────────────────────────┐
  │ [Hook: SnapshotCapture]                           │
  │   ↓                                               │
  │ GenerateParameters.run({acoustics, user_params})  │
  │   → saves snapshot for :parameters stage          │
  │   ↓                                               │
  │ Render.run(final_parameters)                      │
  │   → saves snapshot for :render stage              │
  │   → returns :audio                                │
  └──────────────────────────────────────────────────┘
        │
        ▼
  broadcast_results → LiveView UI 更新波形显示
```

---

## 9. 进阶考虑

<details>
<summary><strong>9.1 跨 Segment 依赖</strong></summary>

某些合成引擎需要考虑相邻乐句的衔接（如音素的协同发音 coarticulation）。可以建模为跨 segment 的依赖：

```elixir
defmodule Cantor.Steps.ExtractPhonemesWithContext do
  use Orchid.Step

  @impl true
  def run({notes_param, prev_tail_param, next_head_param}, opts) do
    notes = notes_param.payload
    prev_tail = prev_tail_param.payload  # 前一乐句末尾的音素
    next_head = next_head_param.payload  # 后一乐句开头的音素
    
    phonemes = PhonemeEngine.extract_with_context(notes, prev_tail, next_head, opts)
    {:ok, Orchid.Param.new(:phonemes, :list, phonemes)}
  end
end
```

这意味着当 $\text{Segment}_i$ 的音符改变时，$\text{Segment}_{i-1}$ 和 $\text{Segment}_{i+1}$ 也可能需要部分重算。DiffEngine 需要扩展为考虑邻居影响的「波及分析」（ripple analysis）。

</details>

<details>
<summary><strong>9.2 更复杂的异质 DAG：不同 Segment 使用不同引擎</strong></summary>

如果不同 segment 可能使用不同的合成引擎（如 NNSVS vs ENUNU vs 自定义模型），Recipe 的结构会完全不同：

```elixir
defmodule Cantor.RecipeFactory do
  def build(segment, change_level, snapshots) do
    case segment.render_config.engine do
      :nnsvs ->
        build_nnsvs_recipe(segment, change_level, snapshots)
      :enunu ->
        build_enunu_recipe(segment, change_level, snapshots)
      :diffsinger ->
        build_diffsinger_recipe(segment, change_level, snapshots)
    end
  end

  defp build_diffsinger_recipe(segment, :full, _snapshots) do
    # DiffSinger 有自己独特的 pipeline
    steps = [
      {Steps.DiffSinger.EncodeInput, :notes, :encoded_input, []},
      {Steps.DiffSinger.RunDiffusion, {:encoded_input, :user_parameters}, :mel_spectrogram,
        [diffusion_steps: segment.render_config.quality]},
      {Steps.DiffSinger.Vocoder, :mel_spectrogram, :audio, []}
    ]
    # ...
  end
end
```

这就是你说的「异质性」——批量 `[A, AB, AB, C, C, ...]` 中，不同类型的 segment 产生完全不同的 DAG 拓扑，但它们可以并发执行。

</details>

<details>
<summary><strong>9.3 优先级调度：用户正在看的区域优先计算</strong></summary>

```elixir
defmodule Cantor.PriorityScheduler do
  @doc """
  根据用户当前视口位置，对 segments 排序。
  正在查看的 segment 优先计算。
  """
  def prioritize(segment_tasks, viewport_range) do
    segment_tasks
    |> Enum.sort_by(fn {segment, _level, _recipe} ->
      distance = range_distance(segment.time_range, viewport_range)
      {distance, -priority_for_level(segment)}
    end)
  end

  defp range_distance({seg_start, seg_end}, {vp_start, vp_end}) do
    cond do
      seg_end < vp_start -> vp_start - seg_end
      seg_start > vp_end -> seg_start - vp_end
      true -> 0  # overlapping = highest priority
    end
  end
end
```

</details>

<details>
<summary><strong>9.4 用 Orchid 的 NestedStep 实现模块化</strong></summary>

可以将整个「单 segment 计算」封装为 NestedStep，然后在更高层级组织跨 segment 的协调：

```elixir
# 将单个 segment 的 pipeline 封装成一个 NestedStep
segment_sub_recipe = Cantor.RecipeFactory.build(segment, :full, [])

# 在 track 级别的 recipe 中组合多个 segment
track_recipe = Recipe.new([
  # 所有 segment 并行计算（它们之间没有依赖）
  {Orchid.Step.NestedStep, :seg_1_input, :seg_1_audio,
    [recipe: seg_1_recipe, input_map: %{...}, output_map: %{...}]},
  {Orchid.Step.NestedStep, :seg_2_input, :seg_2_audio,
    [recipe: seg_2_recipe, input_map: %{...}, output_map: %{...}]},
  # 最终混合
  {Cantor.Steps.MixAudio, [:seg_1_audio, :seg_2_audio], :final_mix, []}
])
```

</details>

---

## 10. 总结：Orchid 在这个架构中的角色

| 层次 | 职责 | 技术选择 |
|------|------|----------|
| **变更检测** | Diff old vs new segments | 纯函数 + input hash |
| **Recipe 生成** | 根据 diff 动态构建异质 DAG | `Cantor.RecipeFactory` |
| **单 Segment 执行** | 运行一个 segment 的 pipeline | **Orchid Recipe + Steps** |
| **中间结果捕获** | 每个 step 后保存 snapshot | **Orchid Hook** |
| **批量并发调度** | 多个 segment 并行计算 | `Task.async_stream` / **Orchid Async Executor** |
| **上下文传递** | segment_id / version 等 | **Orchid Baggage** |
| **编辑会话** | debounce + cancel + recompute | GenServer |
| **Snapshot 存储** | 高性能中间结果缓存 | ETS |

Orchid 在这个体系中扮演的是 **单 segment pipeline 的 DAG 执行引擎**——它的声明式 step 定义、自动拓扑排序、hook 系统和 baggage 传递机制恰好适配「给定一组输入和一个变化级别，构建并执行最小必要 pipeline」的需求。外层的批量调度、diff 逻辑、snapshot 管理则是 Orchid 之上的增量计算框架层。