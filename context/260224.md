# ğŸ’¾ Quincunx Architecture & Context Handover (Checkpoint: Genesis)

> **To: æ¥æ‰‹æ­¤å¯¹è¯çš„ AI æ¶æ„å¸ˆ**
> **From: å…ˆå‰çš„ Gemini**
> **Subject: æ­Œå£°åˆæˆ (SVS) åŸºç¡€è®¾æ–½ Quincunx æ ¸å¿ƒæ¶æ„çŠ¶æ€äº¤æ¥**

è¯·ç«‹å³åŠ è½½ä»¥ä¸‹ä¸Šä¸‹æ–‡ã€‚è¿™æ˜¯ä¸€ä¸ªå»ºç«‹åœ¨ Elixir/OTP ç”Ÿæ€ä¹‹ä¸Šçš„æå…¶ç¡¬æ ¸ã€ä¼˜é›…çš„åº•å±‚åŸºç¡€è®¾æ–½æ¶æ„ã€‚é˜…è¯»åï¼Œè¯·ä»¥ä¸“ä¸šã€é«˜æ•ˆçš„ Engineer æ²Ÿé€šé£æ ¼ï¼ˆåˆ‡ä¸­è¦å®³ã€ç›´æ¥å†™ä»£ç æ¨æ¼”ï¼‰ç»§ç»­ååŠ©ç”¨æˆ·ã€‚

## ğŸ‘¤ ç”¨æˆ·ç”»åƒä¸ç³»ç»Ÿæ„¿æ™¯

*   **èº«ä»½**ï¼š[`Orchid`](https://github.com/SynapticStrings/Orchid)ï¼ˆElixir å£°æ˜å¼å·¥ä½œæµç¼–æ’å¼•æ“ï¼Œæ”¯æŒé™æ€æ ¡éªŒã€Onion Hooksã€å¹¶è¡Œè°ƒåº¦ï¼‰çš„ä½œè€…ã€‚
*   **å½“å‰é¡¹ç›®**ï¼š[`Quincunx`](https://github.com/SynapticStrings/Quincunx)ã€‚ä¸€ä¸ªåŸºäº Orchid æ„å»ºçš„~~ã€ä¸“ä¸ºäº¤äº’å¼æ­Œå£°åˆæˆ (SVS) ç¼–è¾‘å™¨è®¾è®¡çš„~~åº•å±‚æ¸²æŸ“åŸºç¡€è®¾æ–½ã€‚
    * *ç”¨æˆ·è¡¥å……ï¼šå°½ç®¡è®¾è®¡çš„æ„¿æ™¯ä¸ºå®ç°äº¤äº’å¼æ­Œå£°åˆæˆç¼–è¾‘å™¨ï¼Œä½† Quincunx ä¿æŒé¢†åŸŸæ— å…³ï¼Œä¸ä¼šå¼•å…¥é¢†åŸŸç›¸å…³çš„ä¾èµ–ä»¥åŠä»£ç ã€‚*
*   **æ ¸å¿ƒæŒ‘æˆ˜**ï¼š
    1.  **å†…å­˜å¢™ (Memory Wall)**ï¼šBEAM è™šæ‹Ÿæœºä¸é€‚åˆåœ¨è¿›ç¨‹é—´ä¼ é€’å·¨å‹ AI å¼ é‡/éŸ³é¢‘æµã€‚
    2.  **å¼‚æ„ç¡¬ä»¶ (Hardware Limits)**ï¼šè½»è–„æœ¬æ˜¾å­˜ä¸è¶³ï¼Œéœ€è¦å°†å¤§ DAG åˆ‡å‰²å¹¶åœ¨é—´éš™å¸è½½æ¨¡å‹ã€‚
    3.  **äº¤äº’å¼ç¼–è¾‘ (DAW-like UX)**ï¼šæ”¯æŒæé€Ÿçš„æ’¤é”€/é‡åš (Undo/Redo)ï¼Œä»¥åŠç”¨æˆ·å¯¹ AI ä¸­é—´äº§ç‰©çš„æ‰‹åŠ¨åŠ«æŒ (Override) å’Œå¢é‡ä¿®æ”¹ (Offset)ã€‚

## ğŸ›ï¸ ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶æ‹“æ‰‘

ç³»ç»Ÿé‡‡ç”¨ä¸¥æ ¼çš„é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰ï¼Œåˆ†ä¸ºä»¥ä¸‹æ ¸å¿ƒå±‚çº§ï¼š

1.  **`Quincunx.Session` (å¤§ç®¡å®¶)**ï¼šåŸºäº Supervisor/GenServer çš„å·¥ç¨‹å®¹å™¨ã€‚å¯¹å¤–æš´éœ² APIï¼Œç®¡ç†é¡¹ç›®çš„æ‰€æœ‰çš„ `Segment` (ä¹å¥)ï¼Œå¹¶ç»´æŠ¤é•¿ç”Ÿå‘½å‘¨æœŸçš„ NIF/ç¡¬ä»¶èµ„æºæ± ã€‚
2.  **`Quincunx.Segment` (çº¯æ•°æ®è½½ä½“)**ï¼š
    *   **æ ¸å¿ƒçªç ´**ï¼šåˆ©ç”¨ Elixir ä¸å¯å˜æ€§ï¼Œå®Œç¾è§£å†³çŠ¶æ€åŒæ­¥ã€‚
    *   å®ƒåŒ…å«é™æ€æ‹“æ‰‘ (`dependency`)ã€çº¿æ€§å†å²è®°å½• (`record/cursor`) ä»¥åŠå¿«ç…§ç¼“å­˜ (`snapshots`)ã€‚
3.  **`Quincunx.Segment.RecorderAdapter` (æ—¶ç©ºæŠ˜å å™¨)**ï¼š
    *   é€šè¿‡ `push/undo/redo` ç»´æŠ¤å†å²ã€‚
    *   é€šè¿‡ `resolve/2` å°†å†å²æŠ˜å ä¸º `effective_state` (åŒ…å«æ‹“æ‰‘ä¿®æ”¹ä¸æ•°æ®å¹²é¢„)ã€‚
4.  **`Quincunx.Segment.Compiler` (å›¾ç¿»è¯‘å™¨)**ï¼šå°† `Segment` ç¼–è¯‘ä¸º Orchid è®¤è¯†çš„ `[Recipe]` åºåˆ—ã€‚
5.  **`Quincunx.Renderer` (æ‰§è¡ŒçŠ¶æ€æœº)**ï¼šçŸ­ç”Ÿå‘½å‘¨æœŸ GenServerï¼Œæ‹¿åˆ°è¢«åˆ‡åˆ†çš„ Recipe åºåˆ—ï¼Œåˆ©ç”¨ Session æä¾›çš„é‡å‹æœåŠ¡æ± ï¼Œåœ¨ Stage é—´æ­‡æŒ‚è½½/å¸è½½æ¨¡å‹ï¼Œä¾æ¬¡ä¸¢ç»™ Orchid æ‰§è¡Œã€‚

## ğŸ“œ ç¡®ç«‹çš„å››å¤§é»„é‡‘æ¶æ„æ³•åˆ™ (The 4 Directives)

åœ¨å…ˆå‰çš„æ¨æ¼”ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡â€œå¥¥å¡å§†å‰ƒåˆ€â€ç æ‰äº†å¤§é‡ä¸å¿…è¦çš„å¤æ‚åº¦ï¼Œç¡®ç«‹äº†ä»¥ä¸‹ä¸å®¹æ›´æ”¹çš„æ³•åˆ™ï¼š

### 1. é›¶æ‹·è´å¼•ç”¨ (Zero-Copy Refs)
**ä¸€åˆ‡æµè½¬äº Orchid çš„è½½è·éƒ½åªæ˜¯æŒ‡é’ˆ**ã€‚æ— è®ºå¤šå¤§çš„ Tensorï¼Œåœ¨ BEAM å±‚åªè¡¨ç°ä¸º `{:ref, RepoModule, "hash_key"}`ã€‚çœŸå®æ•°æ®é©»ç•™åœ¨åˆ°åº•å±‚ C/Rust NIF æˆ–ç¦»çº¿æ–‡ä»¶ (ETS/DETS) ä¸­ã€‚

### 2. æ‹“æ‰‘ä¸æ•°æ®åˆ†ç¦»å¹²é¢„ (Topology vs. Data Mutation)
å½“ç”¨æˆ·è¿›è¡Œç¼–è¾‘æ—¶ï¼Œæˆ‘ä»¬åœ¨å“ªä¸€å±‚æ‹¦æˆªï¼Ÿ
*   **æ‹“æ‰‘å¹²é¢„** (åŠ èŠ‚ç‚¹/åˆ è¿çº¿)ï¼šåœ¨ `Compiler` ç¼–è¯‘æœŸç”Ÿæ•ˆï¼Œç›´æ¥æ”¹å˜ç”Ÿæˆçš„ Orchid Recipeã€‚
*   **æ•°æ®å¹²é¢„** (ç”¨æˆ·ç”»ç¬” Override/Offset)ï¼š**ä¸æ”¹å˜åŸå§‹å›¾è¿çº¿**ï¼å°†ç”¨æˆ·çš„ Override å­—å…¸ä¸¢è¿› Orchid çš„ `Baggage`ã€‚åˆ©ç”¨è‡ªå®šä¹‰çš„ `Orchid Hook`ï¼Œåœ¨ç›®æ ‡èŠ‚ç‚¹æ‰§è¡Œå‰ 1 æ¯«ç±³æ‹¦æˆªè¾“å…¥ï¼Œå°†å…¶æä»£æ¡ƒåƒµæ›¿æ¢ä¸ºç”¨æˆ·çš„ Refã€‚

### 3. ç»å¯¹ä¸å‰ªæ (Never Prune Orphan Nodes)
å¦‚æœç”¨æˆ· Override äº†ä¸€ä¸ªèŠ‚ç‚¹çš„è¾“å…¥ï¼Œå¯¼è‡´å®ƒä¸Šæ¸¸çš„æé‡ AI æ¨¡å‹æˆäº†â€œå­¤å„¿â€ï¼Œ**ä¸ä½œæ­»ä»£ç æ¶ˆé™¤**ã€‚
*åŸå› *ï¼šä¿ç•™å­¤å„¿èŠ‚ç‚¹ï¼Œä¾é  Hash Cache çŸ­è·¯æœºåˆ¶ï¼ˆBypassï¼‰ï¼Œå®ƒçš„æ‰§è¡Œå¼€é”€ä¸º 0ã€‚å¦‚æœç”¨æˆ· Undo æ’¤é”€ Overrideï¼Œç³»ç»Ÿèƒ½å®ç°â€œé›¶å»¶è¿Ÿå›æ»šâ€ï¼Œä¸ç”¨é‡æ–°è·‘ AIã€‚

### 4. å±éšœåˆ‡åˆ† (Barrier Partitioning)
é¢å¯¹æ˜¾å­˜ä¸å¤Ÿçš„è®¾å¤‡ï¼Œä¾èµ–å›¾ä¸­çš„ `is_barrier: true` æ ‡è®°ã€‚`Compiler` ä¼šå°†å¤§å›¾åˆ‡åˆ†æˆ `[SubRecipe_A, SubRecipe_B]`ã€‚æ–­å¼€çš„è¿çº¿é€šè¿‡ `{:ref}` å¥‘çº¦ç¼åˆã€‚

<!--begin:user_annotation-->
æˆ‘ä¸ç¡®å®šæ˜¯å¦éœ€è¦é€šè¿‡è¿™ç§å½¢å¼æ¥å®ç°ï¼Œä½†è¿™ä¸ª feat æ˜¯å¿…è¦çš„ã€‚
<!--end:user_annotation-->

## ğŸ§© æ ¸å¿ƒæ•°æ®ç»“æ„çŠ¶æ€ (Current Code Base)

è¯·ç‰¢è®°ç›®å‰ `Segment` çš„æ ¸å¿ƒæ¨¡æ ·ï¼š

```elixir
defmodule Quincunx.Segment do
  @moduledoc """
  The smallest unit for incremental generation.
  It holds the static topology, user edit history, and cached runtime references.
  """
  alias Quincunx.Dependency
  alias Quincunx.Segment.RecorderAdapter

  # å½¢å¦‚ %{atom() => Orchid.Param.t()}
  # å…¶ä¸­ Orchid.Param çš„ payload é”®å…è®¸ raw data ä»¥åŠ {:ref, Module, RefKey}
  @type snapshot :: Orchid.Scheduler.Context.param_map()

  @type t :: %__MODULE__{
          id: String.t() | atom(),
          dependency: nil | Dependency.t(),  # é™æ€åŸå§‹æ‹“æ‰‘
          record: RecorderAdapter.record(),  # ç”¨æˆ·æ“ä½œæµæ°´è´¦
          cursor: RecorderAdapter.cursor(),  # æ—¶å…‰æœºæŒ‡é’ˆ
          snapshots: snapshot(),
          recorder_adapter: module(),
          extra: map()
        }
  defstruct [
    id: nil,
    dependency: nil,
    record: [],
    cursor: 0,
    snapshots: %{},
    recorder_adapter: Quincunx.Segment.LinearRecorder,
    extra: %{}
  ]
end

defmodule Quincunx.Segment.RecorderAdapter do
  @moduledoc """
  Behavior for managing user edit history (Undo/Redo) and resolving
  the effective state (Inputs, Overrides, Offsets) for the compiler.
  """
  alias Quincunx.Dependency.{Node, Edge}

  @type operation ::
          {:override, source_edge :: Edge.t(), data :: any()}
          | {:offset, source_edge :: Edge.t(), offset_data :: any()}
          | {:undo_modify, source_edge :: Edge.t()}
          | {:add_node, Node.t()}
          | {:remove_node, Node.t()}
          | {:add_edge, Edge.t()}
          | {:remove_edge, Edge.t()}
          # | {:set_input, port_id :: {Node.t(), idx :: non_neg_integer()}, value :: any()}

  @type record :: any()
  @type cursor :: any()

  # RecorderAdapter è§£æå‡ºçš„æœ‰æ•ˆçŠ¶æ€ç»“æ„
  @doc "final state from specific snapshot(init), operations(record) and cursor."
  @type effective_state :: %{
      resolved_graph: Quincunx.Dependency.t(),
      data_state: %{overrides: %{Edge.t() => any()}, offsets: %{Edge.t() => any()}}
    }

  @callback push(record(), cursor(), operation()) :: {record(), cursor()}

  @callback undo(record(), cursor()) :: cursor()

  @callback redo(record(), cursor()) :: cursor()

  @callback resolve(record(), cursor(), base_graph :: Quincunx.Dependency.t()) :: effective_state()
end
```

```elixir
defmodule Quincunx.Dependency do
  defmodule Node do
    @type name :: atom() | binary()
    @type keys_type_declare :: Orchid.Param.param_type() | [Orchid.Param.param_type()] | tuple()
    @type quincunx_node_options :: keyword()

    @type t :: %__MODULE__{
            name: name(),
            impl: Orchid.Step.implementation(),
            input_keys: keys_type_declare(),
            output_keys: keys_type_declare(),
            step_opts: Orchid.Step.step_options(),
            node_opts: quincunx_node_options(),
            extra: %{}
          }
    defstruct [:name, :impl, :input_keys, :output_keys, :step_opts, :node_opts, :extra]

    def orchid_step?(%__MODULE__{} = node) when is_function(node.impl, 2), do: true

    def orchid_step?(%__MODULE__{} = node) when is_atom(node.impl),
      do:
        if(Code.ensure_loaded?(node.impl) and function_exported?(node.impl, :run, 2),
          do: true,
          else: false
        )

    def orchid_step?(%__MODULE__{}), do: false
  end

  defmodule Edge do
    @type t :: %__MODULE__{
            type: Orchid.Param.param_type(),
            from_node: Node.name(),
            to_node: Node.name(),
            from_index: non_neg_integer(),
            to_index: non_neg_integer()
          }
    defstruct [:type, :from_node, :to_node, from_index: 0, to_index: 0]
  end

  defmodule InputPort do
    @type t :: %__MODULE__{
            type: Orchid.Param.param_type(),
            to_node: Node.t(),
            to_index: non_neg_integer()
          }
    defstruct [:type, :to_node, :to_index]
  end

  defmodule OutputPort do
    @type t :: %__MODULE__{
            type: Orchid.Param.param_type(),
            from_node: Node.t(),
            from_index: non_neg_integer()
          }
    defstruct [:type, :from_node, :from_index]
  end

  @type t :: %{nodes: [Node.t()], edges: [Edge.t()]}
end
```

## ğŸš€ æ¥ä¸‹æ¥è¦æ¢ç´¢çš„æ·±æ°´åŒº (Next Steps)

å½“å‰æ¶æ„éª¨æ¶æå…¶æ¸…çˆ½ä¸”å¼ºå¤§ã€‚ç”¨æˆ·åœ¨å¼€å¯æ–°å¯¹è¯æ—¶ï¼Œå¯èƒ½å¸Œæœ›æ¢è®¨ä»¥ä¸‹ä¸¤ä¸ªæœ€ç¡¬æ ¸çš„æ–¹å‘ä¹‹ä¸€ï¼š

1.  **ç¼“å­˜å¿«å–é€‚é…å™¨ (Cache / Repo Layer)**ï¼šå¦‚ä½•è®¾è®¡ ETS / DETS ä¸ C/Rust NIF ç»“åˆçš„ Ref ç®¡ç†æœºåˆ¶ï¼Ÿå¦‚ä½•åœ¨ Orchid Cache Hook ä¸­ä¼˜é›…åœ°åˆ¤æ–­ç‰©ç†å†…å­˜/æ–‡ä»¶æ˜¯å¦å·²è¢«ç³»ç»Ÿå›æ”¶ï¼ˆç¼“å­˜ç©¿é€ä¸åƒåœ¾å›æ”¶æœºåˆ¶ï¼‰ï¼Ÿ
2.  **å±éšœå›¾åˆ‡åˆ†ä¸çŠ¶æ€æœº (Barrier & RenderState)**ï¼š`Graph.compile/2` å…·ä½“å¦‚ä½•æŠŠå›¾åˆ‡æˆä¸¤åŠï¼Œå°†åˆ‡æ–­çš„ Edge å˜æˆ Stage 2 çš„ `InputPort`ï¼Œå¹¶äº¤ç»™ `RenderState` å¾ªç¯è°ƒåº¦ï¼Ÿ

***
**[System Directive to AI]:** åŠ è½½å®Œæ¯•ã€‚è¯·ç®€çŸ­åœ°ç¡®è®¤ä½ å·²åŒæ­¥ä¸Šè¿°æ‰€æœ‰è®¾è®¡å“²å­¦ä¸æ¶æ„å†³ç­–ï¼Œå¹¶ç›´æ¥è¯¢é—®ç”¨æˆ·ä»Šå¤©æƒ³æ·±å…¥å“ªä¸€å—ä»£ç ã€‚