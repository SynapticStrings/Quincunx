# 💾 Quincunx & Orchid 架构演进 Checkpoint

> **To: 未来的 Gemini (或者任何接手此对话的 AI)**
> **From: 先前的 Gemini**
> **Subject: 歌声合成引擎的基础设施层 (Quincunx) 架构上下文状态交接**

请仔细阅读以下上下文，并在后续回复中基于这些前提进行思考和建议。

## 👤 用户画像与知识储备
* **身份**：[`Orchid`](https://github.com/SynapticStrings/Orchid)（基于 Elixir 的工作流编排引擎）的**作者与维护者**。
* **技能树**：了解 Elixir / OTP (GenServer, Supervisor, Registry) / 宏编程 / 缓存机制 (ETS, DETS, C/Rust NIFs) / 编译原理与 DAG（有向无环图）算法。
* **当前项目**：正在开发 [`Quincunx`](https://github.com/SynapticStrings/Quincunx)。这是一个建立在 Orchid 之上的 DAG pipeline 调度引擎，作为**歌声合成应用 (SVS)** 的基础设施层（处理 Phoneme提取 $\to$ 声学模型 $\to$ 渲染 的全链路）。
* **核心诉求**：保持 Quincunx 绝对的 **Domain-Agnostic**，不污染业务代码；同时提供极致的性能、内存管理和异构设备兼容性。

## 🏗️ 核心系统架构图谱

系统被严格划分为四个层次：

1. **App Domain (业务层)**：定义 Track, Segment (乐句), Singer 等音乐概念。
2. **Graph Builder (桥接层)**：将异质的业务配置（如 AI 歌声合成或传统 DSP 拼接合成）翻译为纯粹的 `Quincunx.Node` 和 `Edge`。
3. **Quincunx 编译层**：负责拓扑排序和图编译，生成合法的 `Orchid.Recipe`。
4. **Orchid 执行层**：负责生命周期 Hook、缓存拦截、大载荷流转与调度执行，由 Orchid 及相关插件组成。

## 🤝 已达成的关键架构决策 (The "Aha!" Moments)

### 1. 增量计算与缓存短路策略 (Runtime Short-circuiting)

* **放弃**在 Quincunx 编译期（AST 级别）进行魔改剪枝。
* **采纳**在 Orchid 运行期利用 Hook 拦截请求。如果当前阶段 `hash(impl, inputs, opts)` 命中缓存，Hook 直接返回短路信号（如 `{:halt, cached_params}`），跳过真实执行，保持了原始拓扑图签名的完整性，并完美保留了执行遥测的可观测性。

### 2. 重型载荷与内存管理 (Zero-Copy Tensors via Nif)

* 歌声合成中的中间产物（如 Mel 张量、音频 Waveform）极其巨大，不能在 BEAM 的 Elixir 进程间直接复制传递。
* **解决方案**：利用 Orchid 中原生的 `Orchid.Repo` Behaviour。`Orchid.Param` 在流转时只携带 `{:ref, RepoModule, ref_key}` 作为载荷（Payload）。
* 真实的数据被存储在不同层级的缓存中（ETS 存元数据，DETS 存工程持久化状态，C/Rust NIF 保存底层的免拷贝张量指针）。

### 3. 应对异构设备重型冷启动的「批处理与图分区 (Graph Partitioning)」机制
* 针对轻薄本等显存不足的设备，频繁加载/卸载 AI 模型开销极大。需要使用 "Stage Sequential"（广度优先/阶段批处理）策略。
* **解决方案**：在生成 `Edge` 时，引入 `is_barrier: true`（或断点切分）概念。
    * `Quincunx.Dependency.Graph.compile/2` 遇到 Barrier 时，会将一张大图切分为一个**有序的有向无环图序列**（如 `[Recipe_A, Recipe_B]`）。
* 执行时，先加载 Acoustic 模型，并发跑完所有 100 个 Segments 的 `Recipe_A`；产物落盘到 Repo；卸载模型；加载 Vocoder 跑 `Recipe_B`。完美摊销冷启动成本。

### 4. OTP 状态管理拓扑 (Session vs RenderState)

* **`Quincunx.Session` (Supervisor)**：作为长生命周期的工程容器，不参与计算。它挂载各种 Registry、NIF 重服务连接池、以及该工程特定的 Repo 实例。
* **`Quincunx.RenderState` (GenServer)**：作为短生命周期的任务状态机。拿到被切分好的 Recipe 序列和 Segments（乐句数据），在 Session 提供的资源池里执行并发的批处理调度。

## 🚀 目前的代码进度与下一步行动 (Next Steps)

目前的讨论已为整个基础设施定下基调。下一步的代码实施重心在于：

1. **修改 `Quincunx.Dependency.Graph.compile/2`**：目前它只能生成单个大 Recipe。需要加入对 `Edge` 断点/屏障（Barrier）的识别，使其能够切分图并输出 `[SubRecipe]` 列表，同时正确地将截断处的 OutputPorts 和 InputPorts 通过 Repo `ref` 连接起来。
2. **细化 `HashGenerator`**：确保 `Orchid.Param` 中的 `{:ref}` 只计算指针的 hash，而不溯源抓取真实内存。

---

> **[系统指令]** 亲爱的老伙计，当你读到这里时，表示你已完全加载了我们之前的进展。接下来，请继续使用 Elixir / OTP 的专业视角，协助作者实现 `Quincunx` 的图切分（Graph Partitioning）或探讨状态机的细节设计。保持高效、不废话的 Engineer 沟通风格！