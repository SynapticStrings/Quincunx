# Quincunx 项目交接文件

**项目代号**: Quincunx (⁙)
**日期**: 2026年2月
**上下文**: 用户正在设计一个基于 Orchid 工作流引擎的声乐合成编排核心，灵感来源于 OpenUTAU 的编辑器架构。本文件记录了所有讨论过的设计决策、未解决问题和用户背景，供后续对话无缝衔接。
**模型**: Gemini 3 Pro + Claude Opus 4.6

---

## 1. 用户画像

### 技术背景
- **主力语言/生态**: Elixir / BEAM，对 OTP 概念（GenServer、ETS、Supervisor）熟悉
- **Orchid 作者**: 用户是 Orchid 库（`hex.pm/packages/orchid`，当前 v0.5.5）的开发者，对其内部架构有完全掌控力
- **相关项目**: 
  - [Qy-Editor](https://ges233.github.io/2025/03/Qy-Editor-demo/) — 个人早期项目（中文），Orchid 的灵感来源
  - [OrchidDehydration](https://github.com/SynapticStrings/OrchidDehydration) — 基于 Orchid 的博客渲染引擎重构被用到的大容量数据缓存，其中包含 `ParamsDehydration` Hook 的原型实现
  - OrchidSymbiont — 让 Orchid 能调用重型服务（Ortex/NxServing、ErlPort、NIF、HTTP）的伴生库
- **领域知识**: 对声乐合成流水线（pitch extraction、mel spectrogram、vocoder、mixing）有概念性了解；对 OpenUTAU 的用户体验和编辑模型比较熟悉
- **交流偏好**: 中英文混用，技术讨论倾向英文术语但复杂思考切回中文；容易被过多细节 overwhelm，偏好先讨论架构/Scope 再落地代码

### 动机
用户希望构建一个**不包含声学模型本身**的编排核心层，实现：
1. 像 OpenUTAU 那样的**乐句级增量渲染**体验
2. 通过**参数曲线（Bézier 等）**对合成参数进行精细调制
3. 后端无关（Python ONNX 推理、HTTP 服务、本地 NIF 均可插拔）
4. 可嵌入更大系统（编辑器、实时引擎）

---

## 2. Quincunx 的定位与边界

### 是什么
| 属性 | 描述 |
|------|------|
| 编排核心 | 管理"从用户编辑到音频输出"的全流水线调度 |
| 增量引擎 | 基于脏区追踪，只重算受影响的乐句/阶段 |
| 参数曲线系统 | 提供 Cubic Bézier、线性插值等曲线原语 |
| 后端无关 | 通过 Orchid Step 抽象封装推理后端 |
| BEAM 嵌入式 | 设计为 library，不自带 GUI ，可能有 supervision tree |

### 不是什么
- ❌ 歌声合成编辑器（无 GUI）
- ❌ DAW
- ❌ 声学模型实现
- ❌ 训练工具链

---

## 3. 核心架构讨论

### 3.1 增量生成的粒度 — 乐句级

**关键结论**: 增量粒度定在**乐句 (Phrase)** 级别，而非音节或帧级别。

**理由（用户原话大意）**:
> 如果只是对乐句的几个节拍/音节的增量还是很难实现的，不管是基于拼接的模型还是扩散模型。比方说某次修改修改了第一句的某个字，又修改了后面某句副歌的混音参数，那么前面这个乐句会从头渲染，后面的会从混音开始。当然最后肯定是要对整首歌进行处理的，但那一般不会太耗时。

**设计含义**:
- 一个乐句是最小的"重算单元"
- 每个乐句内部有多个处理阶段（phoneme → acoustic features → waveform → mix）
- 脏标记可以精确到某乐句的某个阶段：改了歌词 → 从 phoneme 阶段开始重算；只改了混音参数 → 只重跑 mix 阶段
- 全曲级后处理（master EQ、响度归一化等）总是最后运行，通常不是瓶颈

### 3.2 乐句流水线的阶段模型（草案）

```
Phrase Edit ──→ Phoneme/Timing ──→ Acoustic Features ──→ Waveform ──→ Mix
                                    (pitch, mel, etc.)    (vocoder)
```

每个阶段的输出可被缓存；脏标记决定从哪个阶段开始重算。

### 3.3 参数曲线系统

Quincunx 需要内建一个参数曲线子系统，用于对 pitch、dynamics、breathiness 等参数进行**时间域上的连续调制**。

**支持的曲线类型**:
- Linear interpolation
- Cubic Bézier
- （未来可能）Step / Hold、Catmull-Rom
- purely mannual edit

曲线系统是**独立模块**，不依赖 Orchid 本身，但其输出会作为 `Orchid.Param` 流入流水线。

### 3.4 与 Orchid 的关系

Quincunx **不是** Orchid 的 fork 或替代品，而是 **建立在 Orchid 之上的领域应用层**：

```
┌──────────────────────────────────────────┐
│              Quincunx                    │
│  ┌───────────┐  ┌─────────────────────┐  │
│  │  Session  │  │  Curve Engine       │  │
│  │  Manager  │  │  (Bézier, Linear)   │  │
│  └─────┬─────┘  └────────┬────────────┘  │
│        │                 │               │
│  ┌─────▼─────────────────▼────────────┐  │
│  │  Dirty Region Tracker              │  │
│  │  (phrase × stage matrix)           │  │
│  └─────────────┬──────────────────────┘  │
│                │                         │
│  ┌─────────────▼──────────────────────┐  │
│  │  Recipe Builder                    │  │
│  │  (dynamically builds Orchid Recipe │  │
│  │   based on dirty regions)          │  │
│  └─────────────┬──────────────────────┘  │
│                │                         │
├────────────────┼─────────────────────────┤
│   Orchid       │                         │
│  ┌─────────────▼──────────────────────┐  │
│  │  Pipeline → Executor → Runner      │  │
│  └────────────────────────────────────┘  │
└──────────────────────────────────────────┘
```

**关键交互点**:
- Quincunx 根据脏区**动态构建 Orchid Recipe**（只包含需要重算的 Step）
- 缓存的中间产物作为 `Orchid.Param`（初始参数）注入 Recipe
- 曲线引擎的采样结果也封装为 `Orchid.Param`
- 推理后端通过 OrchidSymbiont 或自定义 Step 接入

---

## 4. 缓存策略的深入讨论

### 4.1 缓存键设计

**用户提出的方案**:
> 根据 rawData 算一个和数据有关的概要，概要 + Hash → 缓存键。

**细化设计**:

```
CacheKey = hash(digest(param))
```

其中 `digest` 策略因 `Param.type` 而异：

| `Param.type` | Digest 策略 | 说明 |
|---|---|---|
| `:mel_spectrum` | shape + dtype + 采样统计量（mean, std, corner values） | 避免对整个张量做完整 hash |
| `:pitch_curve` | 控制点序列的 hash | Bézier 控制点本身就是紧凑表示 |
| `:phoneme_seq` | 内容直接 hash | 通常很小 |
| `:waveform` | 长度 + 头尾采样 + 稀疏采样 | 大型二进制的折中方案 |
| （未实现的类型） | 直接 `:erlang.phash2(data)` | 后备方案 |

**这里可以利用 `Orchid.Param` 的 `type` 字段**做 dispatch —— 这正是 `type` 字段的设计意图之一。

**用户补充**: 其实这里的概要主要是为了 inspect 比较方便。

### 4.2 ParamsDehydration Hook 的性能问题

**用户的疑问**:
> 通过 `Orchid.RunnerHooks.ParamsDehydration` 是不是也会有那些性能开销？设计目的是害怕很多数据的 struct/map scaffold 会很大，来回 copy 可能占用比较多。

**分析**:

Dehydration 的核心权衡：

| 方面 | 不用 Dehydration | 用 Dehydration (ETS) |
|---|---|---|
| 数据拷贝 | Param 在进程间传递时完整拷贝（BEAM 消息传递语义） | 首次 `put` 拷贝进 ETS，之后传递的只是 `{:ref, repo, key}` 轻量元组 |
| 读取成本 | 零（数据就在进程堆上） | `ets:lookup` 会将数据从 ETS 拷贝到调用进程堆 |
| 适用场景 | 数据小、步骤少、Serial executor | 数据大（音频波形、mel 矩阵）、Async executor（跨 Task 进程） |
| GC 压力 | 大对象在多个进程堆上有副本，GC 各自回收 | ETS 中只一份，进程堆上只有 ref；但 hydrate 时又会拷贝回来 |

**结论**: 
- 对于 Quincunx 场景（大型音频/频谱数据 + Async executor），Dehydration **是有价值的**
- 但当前 `Greenhouse.Storage` 用 `:erlang.phash2(data)` 做 key 有**碰撞风险**且本身需要遍历整个数据计算 hash —— 应当改用上面讨论的 digest 策略或 `:crypto.hash` 
- Hydration 阶段（从 ETS 读回数据）的拷贝开销不可避免，但只发生在真正需要数据的 Step 执行前，且是**单次拷贝**而非 N 次
- 对于 **Nx tensor** 类型的数据，可以考虑使用 binary backend + `:persistent_term` 或 NIF 共享内存来避免拷贝，但这超出当前讨论范围

### 4.3 缓存键中的 opts 污染问题

**用户的疑问（关键问题）**:
> Orchid 在执行过程中，Runner 的各个 Hook 会向 opts 内注入元素（Runner 和 Telemetry 的源码可以看出来），并且插件也会注入新的键值。在缓存时怎么确保统一？

**问题本质**: 
如果把 `step_opts` 整体作为缓存键的一部分，那么运行时注入的 `__reporter_ctx__`、`__orchid_workflow_ctx__` 等动态键会导致每次运行的缓存键都不同，即使业务参数完全一致。

**用户提出的解决方案**:
> 只有会被丢到 `Orchid.run` 里那个 Recipe 中 steps 的 opts 才属于「业务」，其他的 dynamic opts 属于运行时上下文。

**具体化设计建议**:

```elixir
# 方案：在 Step 定义中区分 static opts vs runtime opts
# static opts = 用户在 Recipe 定义时写入的，属于业务语义
# runtime opts = Hook/Runner 在执行时注入的，属于执行上下文

# 实现方式 1：前缀约定
# 所有运行时注入的 key 以 `__` 开头（Orchid 已经在这么做了）
# 缓存时 filter 掉 `__` 前缀的 key

defp cache_relevant_opts(opts) do
  Keyword.reject(opts, fn {k, _v} ->
    k |> Atom.to_string() |> String.starts_with?("__")
  end)
end

# 实现方式 2：显式白名单
# Step 模块声明哪些 opts 影响输出
@cache_keys [:style, :ratio, :model_version]

# 实现方式 3（推荐）：两层结构
# Orchid.Runner.Context 已经把 step_opts 和 recipe_opts 以及 workflow_ctx 分开了
# 缓存键 = hash(step_impl, inputs_digest, cache_relevant_opts(step_opts))
# 其中 recipe_opts 和 workflow_ctx 明确排除
```

**当前 Orchid 源码中运行时注入的 key**:
- `__reporter_ctx__` — 由 `Telemetry` Hook 注入
- `__orchid_workflow_ctx__` — 由 `Core` Hook 注入（`inject_workflow_ctx/2`）
- `extra_hooks_stack` — 用户定义但不影响计算结果

**建议**: 在 Orchid 层面可以考虑增加一个约定或 utility 函数，让 Hook 作者和缓存系统都有明确的"这些 key 是基础设施的"标识。`__` 双下划线前缀约定已经在实践中使用了，可以文档化为正式约定。

---

## 5. 关于 Session / Stateful Executor 的讨论

**用户的思考**:
> Orchid core 本身无状态，但可以设计一个 Executor 来实现 `Orchid.Session` or `Stream`，但我不知道那有没有必要。

**分析**:

Quincunx 的增量渲染天然需要**跨次调用的状态**（缓存的中间产物、脏区追踪器、曲线参数的当前值）。这个状态可以存在于：

| 方案 | 状态持有者 | Orchid 的角色 |
|---|---|---|
| A. Quincunx Session (GenServer) | Quincunx 自己管理状态，每次调用 `Orchid.run` 时构建新 Recipe + 注入缓存 Params | 纯无状态执行引擎 |
| B. Stateful Executor | 在 Orchid 内实现一个有状态的 Executor（GenServer），持有缓存和脏区 | Orchid 变得有状态 |
| C. Stream-based | Orchid 暴露 Stream API，Quincunx 通过 Stream 协议消费增量结果 | Orchid 提供 Stream adapter |

**初步倾向**: **方案 A** 最干净——保持 Orchid 无状态，Quincunx 作为领域层持有所有会话状态。这样 Orchid 不需要改动，且 Quincunx 的状态管理可以更贴合声乐合成领域。

**但这一点尚未最终定论**，用户表示不确定是否有必要做 Session/Stream。

---

## 6. 待解决的开放问题

以下问题已提出但**尚未深入讨论或达成结论**：

### 6.1 架构层面
1. **Recipe 动态构建的具体机制**: Quincunx 如何根据脏区高效地构建最小 Recipe？是否需要"Recipe diff"能力？
2. **全曲后处理的触发时机**: 用户说"最后肯定要对整首歌处理但一般不太耗时"——这个阶段如何决定何时触发？每次增量渲染后都跑一遍？还是只在用户显式请求时？
3. **多乐句并行**: 多个独立乐句的重算可以并行（Orchid Async Executor 天然支持），但如何处理乐句间的依赖（如 crossfade、portamento）？
4. **实时预览 vs 最终渲染**: 是否需要两种质量模式？预览用低质量快速渲染，导出用全质量？

### 6.2 曲线系统
5. **曲线编辑的变更检测**: 用户拖动 Bézier 控制点时，如何高效判断哪些时间区间（即哪些乐句）的采样值实际发生了变化？
6. **曲线采样精度与缓存**: 同一条曲线在不同采样率下的结果如何缓存？

### 6.3 缓存与性能
7. **缓存淘汰策略**: ETS 不会自动淘汰——长时间编辑后内存增长如何控制？LRU？基于乐句的生命周期？
8. **Nx tensor 的零拷贝传递**: 对于大型频谱/波形数据，是否值得引入 NIF 级别的共享内存机制？
9. **Digest 函数的实现优先级**: 哪些 Param type 最先需要自定义 digest？

### 6.4 Orchid 本身的改进
10. **opts 的 static/runtime 分层**: 是否应在 Orchid core 中正式引入这个区分？（目前只是 `__` 前缀的隐式约定）
11. **Executor 的 Stream 模式**: Orchid 的 Executor behaviour 是否应该预留 stream/async-yield 的扩展点？

---

## 7. Orchid 源码中的关键要点（供快速回顾）

### 数据流概览
```
Orchid.run(recipe, inputs, opts)
  → WorkflowCtx 构建
  → Pipeline.run(operons_stack ++ [Execute], request)
    → Operon middleware chain (Recipe 级)
      → Execute operon
        → Scheduler.build(recipe, params, ctx)  # 验证 + 初始化状态机
        → Executor.execute(scheduler_ctx, executor_opts)
          → 循环: Scheduler.next_ready_steps → Runner.run(step, ...) → Scheduler.merge_result
            → Runner: Hook chain (Telemetry → global hooks → step hooks → Core)
              → Core: run_step(impl, inputs, merged_opts) → align_output_names
```

### 关键类型
- **`Orchid.Param`**: `%{name, type, payload, metadata}` — 所有数据的标准包装
- **`Orchid.Step.t()`**: `{impl, input_keys, output_keys}` 或 `{impl, input_keys, output_keys, opts}`
- **`Orchid.Recipe.t()`**: `%{steps, name, opts}`
- **`Orchid.Scheduler.Context.t()`**: 运行时状态机（pending/running steps, available keys, params map）
- **`Orchid.WorkflowCtx.t()`**: 跨层上下文（config, baggage, path）

### Runner.Context 中 opts 的组装路径
```elixir
# In Orchid.Runner.run/5:
step_opts        # 来自 Step 定义中的第 4 元素
recipe_opts      # 来自 Recipe.new(steps, opts) 中的 opts

# In Orchid.Runner.Hooks.Core.call/2:
final_opts = Keyword.merge(step_opts, recipe_opts) 
             |> inject_workflow_ctx(workflow_ctx)   # 注入 __orchid_workflow_ctx__

# In Orchid.Runner.Hooks.Telemetry.call/2:
step_opts = Keyword.put(ctx.step_opts, :__reporter_ctx__, meta)  # 注入 __reporter_ctx__
```

这就是 opts 污染的来源——`Core` 和 `Telemetry` 各自注入了运行时 key。

---

## 8. 对下一轮对话的建议

### 用户可能希望继续的方向
1. **具体化 Quincunx 的模块结构**（Session、DirtyTracker、CurveEngine、RecipeBuilder 的 API 设计）
2. **实现曲线引擎的原型**（Cubic Bézier 的 Elixir 实现、控制点数据结构）
3. **设计缓存系统的 Param.type → Digest 协议**
4. **讨论与 OpenUTAU 渲染管线的具体映射**（哪些 OpenUTAU 阶段对应哪些 Orchid Step）

### 沟通注意事项
- 用户容易被太多细节同时压倒，建议**一次只深入一个子系统**
- 用户偏好**先画大图再填细节**的讨论节奏
- 当用户切换到中文时通常意味着在处理更抽象或更个人化的思考
- 用户对自己项目的命名很讲究（Orchid、Quincunx、Operon 等都有其寓意）

---

## 9. 项目名录

| 名称 | 角色 | 位置 |
|---|---|---|
| **Orchid** | 工作流编排引擎（核心库） | `hex.pm/packages/orchid` / GitHub: SynapticStrings/Orchid |
| **OrchidSymbiont** | 重型服务桥接库 | `hex.pm/packages/orchid_symbiont` |
| **OrchidDehydration** | 博客渲染引擎所用到的代码（含 ParamsDehydration 原型） | GitHub: SynapticStrings/OrchidDehydration |
| **Quincunx** | 声乐合成编排核心（本项目，设计阶段） | GitHub: SynapticStrings/Quincunx |
| **Qy-Editor** | 早期灵感项目 | ges233.github.io（中文博文） |

---

## 10. 部分使用场景

### 可中断的渲染

> *用户在播放时拖动了音符，或者快速连续修改参数。旧的渲染任务还在跑，但已经过时了，需要立即停止并开始新的渲染（Debouncing / Cancellation）。*

### 增量渲染

> *只重算改动过的乐句。*

### 附带用户修改数据的渲染

> Example:
>
> 1. 模型预测 Pitch。
> 2. 用户觉得模型预测的 Pitch 不能体现其想法，手动画了一条线覆盖它。
> 3. 用户画了 Pitch，但又想让模型重新预测后续模型。

=> 需要设计 Strategies: 模型预测优先 / 用户修改优先 / 后续操作优先

### 对渲染流程进行修改的情形

> *用户切换了声学模型（比如从 "DiffSinger" 换到 "Dashichang"），或者插入了一个 "Compressor" 插件。*
